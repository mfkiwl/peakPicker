%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 24.2 and Fixed-Point Designer 24.2          %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
% Modified from the original peakPicker.m file
% to use a hardware-friendly implementation of peak finder
% This function is used to find the locations of peaks in a cross-correlation
% signal. It takes the cross-correlation signal, a threshold, and a window
% length as inputs, and returns the locations of the detected peaks.
% The function uses a sliding window approach to check for local maxima
% within the specified window length. The middle sample of the window is
% compared to the other samples in the window, and if it is greater than
% the threshold, it is considered a peak. The function also ensures that
% the detected peaks are within the specified window length.
% The function is designed to be hardware-friendly, meaning it is optimized
% for implementation on hardware platforms such as FPGAs or ASICs. It uses
% a simple and efficient algorithm to find the peaks, avoiding complex
% operations that may not be suitable for hardware implementation.
% The function is written in MATLAB and can be used in various applications
% such as signal processing, communications, and data analysis.
%
% The function takes the following inputs:
% - xcorr: The cross-correlation signal, which is a matrix of size
%   (num_samples, num_sequences). Each column represents a different
%   sequence.
% - threshold: The threshold value for peak detection, which is a vector
%   of size (num_samples, 1). The threshold is used to determine if a
%   sample is considered a peak.
% - window_length: The length of the sliding window used for peak
%   detection. It is a scalar value that specifies the number of samples
%   to consider in the window.
%
% The function returns the following output:
% - locations: A vector containing the indices of the detected peaks in
%   the cross-correlation signal. The indices are relative to the input
%   signal and indicate the locations of the detected peaks.
%
% Author: Jie Lei
% Date: 03/31/2025
% University of Technology Sydney
function [locations,valid]= peakPicker_fixpt(xcorr,threshold)
% Copyright 2021-2023 The MathWorks, Inc.
    fm = get_fimath();

    window_length = fi(11, 0, 4, 0, fm); % Length of the sliding window
    middle_location=fi(floor(fi_div_by_shift(window_length, 1)), 0, 3, 0, fm);
    persistent xcorrBuffer; % Persistent buffer for current window
    persistent thresholdBuffer; % Persistent buffer for threshold
    if isempty(xcorrBuffer) % Initialize buffer if empty
        xcorrBuffer = fi(zeros(fi_toint(window_length), 1), 0, 14, 21, fm); % Preallocate buffer for current window
    end
    if isempty(thresholdBuffer) % Initialize threshold buffer if empty
        thresholdBuffer = fi(zeros(fi_toint(window_length), 1), 0, 14, 21, fm); % Preallocate buffer for threshold
    end
    persistent index; % Persistent index for the loop
    if isempty(index) % Initialize index if empty
        index = fi(1, 0, 13, 0, fm); % Start from the first index
    end
    
    xcorrBuffer(2:end,:) = xcorrBuffer(1:end-1,:); % Shift buffer
    xcorrBuffer(1,:) = xcorr; % Add new sample to buffer
    thresholdBuffer(2:end) = thresholdBuffer(1:end-1); % Shift threshold buffer
    thresholdBuffer(1) = threshold; % Add new threshold to buffer
    if (index >= window_length)
        candidate_location = fi(index - middle_location, 0, 13, 0, fm);
        % Hardware friendly implementation of peak finder
        MidSample = fi(xcorrBuffer(middle_location+fi(1, 0, 1, 0, fm),:), 0, 14, 21, fm);
        CompareOut = fi(fi_signed(xcorrBuffer) - MidSample, 1, 14, 20, fm); % this is a vector
        % if all values in the result are negative and the middle sample is
        % greater than a threshold, it is a local max
        if all(CompareOut <= fi(0, 0, 1, 0, fm)) && (MidSample > thresholdBuffer(middle_location+fi(1, 0, 1, 0, fm)))
            locations = fi(candidate_location, 0, 13, 0, fm); % Store the location of the peak
            valid = true; % Set valid to true if a peak is found
        else
            locations = fi(0, 0, 13, 0, fm); % No peak found
            valid = false; % Set valid to false if no peak is found
        end
    else
        locations = fi(0, 0, 13, 0, fm); % No peak found
        valid = false; % Set valid to false if no peak is found
    end
    index(:) = index + fi(1, 0, 1, 0, fm); % Increment index for the next iteration
end



function y = fi_div_by_shift(a,shift_len)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        fm = fimath( a );
        nt_bs = numerictype( nt.Signed, nt.WordLength + shift_len, nt.FractionLength + shift_len );
        y = bitsra( fi( a, nt_bs, fm ), shift_len );
    else
        y = a / 2 ^ shift_len;
    end
end


function y = fi_signed(a)
    coder.inline( 'always' );
    if isfi( a ) && ~(issigned( a ))
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = fi( a, new_nt, fimath( a ) );
    else
        y = a;
    end
end


function y = fi_toint(u)
    coder.inline( 'always' );
    if isfi( u )
        nt = numerictype( u );
        s = nt.SignednessBool;
        wl = nt.WordLength;
        y = int32( fi( u, s, wl, 0, hdlfimath ) );
    else
        y = int32( u );
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
