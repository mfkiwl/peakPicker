// -------------------------------------------------------------
// 
// File Name: /home/jielei/Projects/UTS/peakPicker/HDLCoder/optim2_HDL/codegen/peakPicker/hdlsrc/peakPicker_fixpt_tb.v
// Created: 2025-03-31 22:20:29
// 
// Generated by MATLAB 24.2, MATLAB Coder 24.2 and HDL Coder 24.2
// 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: peakPicker_fixpt_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module peakPicker_fixpt_tb;



  reg  clk;
  reg  reset_x;
  wire enb;
  wire valid_done;  // ufix1
  wire rdEnb;
  wire valid_done_enb;  // ufix1
  reg [12:0] locations_addr;  // ufix13
  wire valid_lastAddr;  // ufix1
  wire resetn;
  reg  check2_done;  // ufix1
  wire locations_done;  // ufix1
  wire locations_done_enb;  // ufix1
  wire locations_active;  // ufix1
  reg [12:0] xcorr_addr;  // ufix13
  wire [12:0] threshold_addr_delay_1;  // ufix13
  wire tb_enb;
  reg signed [31:0] fp_threshold;  // sfix32
  reg [13:0] rawData_threshold;  // ufix14_En21
  reg signed [31:0] status_threshold;  // sfix32
  reg [13:0] holdData_threshold;  // ufix14_En21
  reg [13:0] threshold_offset;  // ufix14_En21
  wire [13:0] threshold;  // ufix14_En21
  wire xcorr_active;  // ufix1
  wire xcorr_enb;  // ufix1
  wire [12:0] xcorr_addr_delay_1;  // ufix13
  reg signed [31:0] fp_xcorr;  // sfix32
  reg [13:0] rawData_xcorr;  // ufix14_En21
  reg signed [31:0] status_xcorr;  // sfix32
  reg [13:0] holdData_xcorr;  // ufix14_En21
  reg [13:0] xcorr_offset;  // ufix14_En21
  wire [13:0] xcorr_1;  // ufix14_En21
  wire snkDone;
  wire snkDonen;
  wire ce_out;
  wire [12:0] locations;  // ufix13
  wire valid;
  wire locations_enb;  // ufix1
  wire locations_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  wire constone;  // ufix1
  reg  locations_chkenb;  // ufix1
  wire locations_chkdata;  // ufix1
  wire [12:0] locations_addr_delay_1;  // ufix13
  reg signed [31:0] fp_locations_expected;  // sfix32
  reg [12:0] locations_expected;  // ufix13
  reg signed [31:0] status_locations_expected;  // sfix32
  wire [12:0] locations_ref;  // ufix13
  reg  locations_testFailure;  // ufix1
  wire constone_1;  // ufix1
  reg  valid_chkenb;  // ufix1
  wire valid_chkdata;  // ufix1
  wire [12:0] valid_addr_delay_1;  // ufix13
  reg signed [31:0] fp_valid_expected;  // sfix32
  reg  valid_expected;
  reg signed [31:0] status_valid_expected;  // sfix32
  wire valid_ref;
  reg  valid_testFailure;  // ufix1
  wire testFailure;  // ufix1


  assign valid_done_enb = valid_done & rdEnb;

  assign valid_lastAddr = locations_addr >= 13'b1011101110001;

  assign valid_done = valid_lastAddr & resetn;

  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset_x)
    begin : checkDone_2
      if (reset_x) begin
        check2_done <= 0;
      end
      else begin
        if (valid_done_enb) begin
          check2_done <= valid_done;
        end
      end
    end

  assign locations_done_enb = locations_done & rdEnb;

  assign locations_active = locations_addr != 13'b1011101110001;

  assign #1 threshold_addr_delay_1 = xcorr_addr;

  // Data source for threshold
  initial
    begin : threshold_fileread
      fp_threshold = $fopen("threshold.dat", "r");
      status_threshold = $rewind(fp_threshold);
    end

  always @(threshold_addr_delay_1, rdEnb, tb_enb)
    begin
      if (tb_enb == 0) begin
        rawData_threshold <= 14'bx;
      end
      else if (rdEnb == 1) begin
        status_threshold = $fscanf(fp_threshold, "%h", rawData_threshold);
      end
    end

  // holdData reg for threshold
  always @(posedge clk or posedge reset_x)
    begin : stimuli_threshold
      if (reset_x) begin
        holdData_threshold <= 14'bx;
      end
      else begin
        holdData_threshold <= rawData_threshold;
      end
    end

  always @(rawData_threshold or rdEnb)
    begin : stimuli_threshold_1
      if (rdEnb == 1'b0) begin
        threshold_offset <= holdData_threshold;
      end
      else begin
        threshold_offset <= rawData_threshold;
      end
    end

  assign #2 threshold = threshold_offset;

  assign xcorr_active = xcorr_addr != 13'b1011101110001;

  assign xcorr_enb = xcorr_active & (rdEnb & tb_enb);

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 6001
  always @(posedge clk or posedge reset_x)
    begin : xcorr_process
      if (reset_x == 1'b1) begin
        xcorr_addr <= 13'b0000000000000;
      end
      else begin
        if (xcorr_enb) begin
          if (xcorr_addr >= 13'b1011101110001) begin
            xcorr_addr <= 13'b0000000000000;
          end
          else begin
            xcorr_addr <= xcorr_addr + 13'b0000000000001;
          end
        end
      end
    end

  assign #1 xcorr_addr_delay_1 = xcorr_addr;

  // Data source for xcorr
  initial
    begin : xcorr_fileread
      fp_xcorr = $fopen("xcorr.dat", "r");
      status_xcorr = $rewind(fp_xcorr);
    end

  always @(xcorr_addr_delay_1, rdEnb, tb_enb)
    begin
      if (tb_enb == 0) begin
        rawData_xcorr <= 14'bx;
      end
      else if (rdEnb == 1) begin
        status_xcorr = $fscanf(fp_xcorr, "%h", rawData_xcorr);
      end
    end

  // holdData reg for xcorr
  always @(posedge clk or posedge reset_x)
    begin : stimuli_xcorr
      if (reset_x) begin
        holdData_xcorr <= 14'bx;
      end
      else begin
        holdData_xcorr <= rawData_xcorr;
      end
    end

  always @(rawData_xcorr or rdEnb)
    begin : stimuli_xcorr_1
      if (rdEnb == 1'b0) begin
        xcorr_offset <= holdData_xcorr;
      end
      else begin
        xcorr_offset <= rawData_xcorr;
      end
    end

  assign #2 xcorr_1 = xcorr_offset;

  assign snkDonen =  ~ snkDone;

  assign resetn =  ~ reset_x;

  assign tb_enb = resetn & snkDonen;

  assign rdEnb = (snkDone == 1'b0 ? tb_enb :
              1'b0);

  assign #2 enb = rdEnb;

  initial
    begin : reset_x_gen
      reset_x <= 1'b1;
      # (20);
      @ (posedge clk)
      # (2);
      reset_x <= 1'b0;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  peakPicker_fixpt u_peakPicker_fixpt (.clk(clk),
                                       .reset_x(reset_x),
                                       .clk_enable(enb),
                                       .xcorr(xcorr_1),  // ufix14_En21
                                       .threshold(threshold),  // ufix14_En21
                                       .ce_out(ce_out),
                                       .locations(locations),  // ufix13
                                       .valid(valid)
                                       );

  assign locations_enb = ce_out & locations_active;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 6001
  always @(posedge clk or posedge reset_x)
    begin : locations_1_process
      if (reset_x == 1'b1) begin
        locations_addr <= 13'b0000000000000;
      end
      else begin
        if (locations_enb) begin
          if (locations_addr >= 13'b1011101110001) begin
            locations_addr <= 13'b0000000000000;
          end
          else begin
            locations_addr <= locations_addr + 13'b0000000000001;
          end
        end
      end
    end

  assign locations_lastAddr = locations_addr >= 13'b1011101110001;

  assign locations_done = locations_lastAddr & resetn;

  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset_x)
    begin : checkDone_1
      if (reset_x) begin
        check1_done <= 0;
      end
      else begin
        if (locations_done_enb) begin
          check1_done <= locations_done;
        end
      end
    end

  assign snkDone = check1_done & check2_done;

  assign constone = 1'b1;

  // Delay to implement IgnoreDataChecking
  always @(posedge clk or posedge reset_x)
    begin : locations_IgnoreDataChecking
      if (reset_x) begin
        locations_chkenb <= 0;
      end
      else begin
        if (ce_out) begin
          locations_chkenb <= constone;
        end
      end
    end

  assign locations_chkdata = ce_out & locations_chkenb;

  assign #1 locations_addr_delay_1 = locations_addr;

  // Data source for locations_expected
  initial
    begin : locations_expected_fileread
      fp_locations_expected = $fopen("locations_expected.dat", "r");
      status_locations_expected = $rewind(fp_locations_expected);
    end

  always @(locations_addr_delay_1, ce_out, tb_enb)
    begin
      if (tb_enb == 0) begin
        locations_expected <= 13'bx;
      end
      else if (ce_out == 1) begin
        status_locations_expected = $fscanf(fp_locations_expected, "%h", locations_expected);
      end
    end

  assign locations_ref = locations_expected;

  always @(posedge clk or posedge reset_x)
    begin : locations_checker
      if (reset_x == 1'b1) begin
        locations_testFailure <= 1'b0;
      end
      else begin
        if (locations_chkdata == 1'b1 && locations !== locations_ref) begin
          locations_testFailure <= 1'b1;
          $display("ERROR in locations at time %t : Expected '%h' Actual '%h'", $time, locations_ref, locations);
        end
      end
    end

  assign constone_1 = 1'b1;

  // Delay to implement IgnoreDataChecking
  always @(posedge clk or posedge reset_x)
    begin : valid_IgnoreDataChecking
      if (reset_x) begin
        valid_chkenb <= 0;
      end
      else begin
        if (ce_out) begin
          valid_chkenb <= constone_1;
        end
      end
    end

  assign valid_chkdata = ce_out & valid_chkenb;

  assign #1 valid_addr_delay_1 = locations_addr;

  // Data source for valid_expected
  initial
    begin : valid_expected_fileread
      fp_valid_expected = $fopen("valid_expected.dat", "r");
      status_valid_expected = $rewind(fp_valid_expected);
    end

  always @(valid_addr_delay_1, ce_out, tb_enb)
    begin
      if (tb_enb == 0) begin
        valid_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_valid_expected = $fscanf(fp_valid_expected, "%h", valid_expected);
      end
    end

  assign valid_ref = valid_expected;

  always @(posedge clk or posedge reset_x)
    begin : valid_checker
      if (reset_x == 1'b1) begin
        valid_testFailure <= 1'b0;
      end
      else begin
        if (valid_chkdata == 1'b1 && valid !== valid_ref) begin
          valid_testFailure <= 1'b1;
          $display("ERROR in valid at time %t : Expected '%h' Actual '%h'", $time, valid_ref, valid);
        end
      end
    end

  assign testFailure = locations_testFailure | valid_testFailure;

  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // peakPicker_fixpt_tb

