-- -------------------------------------------------------------
-- 
-- File Name: /home/jielei/Projects/UTS/peakPicker/HDLCoder/optim2_HDL/codegen/peakPicker/hdlsrc/peakPicker_fixpt.vhd
-- Created: 2025-03-31 22:14:43
-- 
-- Generated by MATLAB 24.2, MATLAB Coder 24.2 and HDL Coder 24.2
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- locations                     ce_out        1
-- valid                         ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: peakPicker_fixpt
-- Source Path: peakPicker_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.peakPicker_fixpt_pkg.ALL;

ENTITY peakPicker_fixpt IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        xcorr                             :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix14_En21
        threshold                         :   IN    std_logic_vector(13 DOWNTO 0);  -- ufix14_En21
        ce_out                            :   OUT   std_logic;
        locations                         :   OUT   std_logic_vector(12 DOWNTO 0);  -- ufix13
        valid                             :   OUT   std_logic
        );
END peakPicker_fixpt;


ARCHITECTURE rtl OF peakPicker_fixpt IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL s                                : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL index                            : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL tmp                              : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL s_1                              : std_logic;
  SIGNAL locations_1                      : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL xcorr_unsigned                   : unsigned(13 DOWNTO 0);  -- ufix14_En21
  SIGNAL tmp_1                            : vector_of_unsigned14(0 TO 10);  -- ufix14_En21 [11]
  SIGNAL xcorrBuffer                      : vector_of_unsigned14(0 TO 10);  -- ufix14_En21 [11]
  SIGNAL MidSample                        : unsigned(13 DOWNTO 0);  -- ufix14_En21
  SIGNAL c                                : std_logic_vector(10 DOWNTO 0);  -- boolean [11]
  SIGNAL p9c_sub_cast                     : vector_of_signed17(0 TO 10);  -- sfix17_En21 [11]
  SIGNAL p9c_sub_cast_1                   : vector_of_signed17(0 TO 10);  -- sfix17_En21 [11]
  SIGNAL p9c_sub_temp                     : vector_of_signed17(0 TO 10);  -- sfix17_En21 [11]
  SIGNAL p9c_cast                         : vector_of_signed14(0 TO 10);  -- sfix14_En20 [11]
  SIGNAL p9c_cast_1                       : vector_of_signed22(0 TO 10);  -- sfix22_En20 [11]
  SIGNAL y_1                              : std_logic;
  SIGNAL threshold_unsigned               : unsigned(13 DOWNTO 0);  -- ufix14_En21
  SIGNAL tmp_2                            : vector_of_unsigned14(0 TO 10);  -- ufix14_En21 [11]
  SIGNAL thresholdBuffer                  : vector_of_unsigned14(0 TO 10);  -- ufix14_En21 [11]
  SIGNAL thresholdBuffer_1                : unsigned(13 DOWNTO 0);  -- ufix14_En21
  SIGNAL y_2                              : std_logic;
  SIGNAL locations_2                      : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL tmp_3                            : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL tmp_4                            : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL tmp_5                            : unsigned(12 DOWNTO 0);  -- ufix13
  SIGNAL valid_1                          : std_logic;
  SIGNAL valid_2                          : std_logic;
  SIGNAL valid_3                          : std_logic;
  SIGNAL tmp_6                            : std_logic;
  SIGNAL tmp_7                            : std_logic;

BEGIN
  s <= to_unsigned(16#0001#, 14);

  enb <= clk_enable;

  tmp <= resize(resize(index, 14) + s, 13);

  index_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      index <= to_unsigned(16#0001#, 13);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        index <= tmp;
      END IF;
    END IF;
  END PROCESS index_reg_process;


  -- Add new threshold to buffer
  
  s_1 <= '1' WHEN index >= to_unsigned(16#000B#, 13) ELSE
      '0';

  locations_1 <= to_unsigned(16#0000#, 13);

  xcorr_unsigned <= unsigned(xcorr);

  -- Increment index for the next iteration
  xcorrBuffer_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      xcorrBuffer <= (OTHERS => to_unsigned(16#0000#, 14));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        xcorrBuffer <= tmp_1;
      END IF;
    END IF;
  END PROCESS xcorrBuffer_reg_process;


  -- Set valid to false if no peak is found
  -- No peak found
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  --                                                                          %
  --          Generated by MATLAB 24.2 and Fixed-Point Designer 24.2          %
  --                                                                          %
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- Modified from the original peakPicker.m file
  -- to use a hardware-friendly implementation of peak finder
  -- This function is used to find the locations of peaks in a cross-correlation
  -- signal. It takes the cross-correlation signal, a threshold, and a window
  -- length as inputs, and returns the locations of the detected peaks.
  -- The function uses a sliding window approach to check for local maxima
  -- within the specified window length. The middle sample of the window is
  -- compared to the other samples in the window, and if it is greater than
  -- the threshold, it is considered a peak. The function also ensures that
  -- the detected peaks are within the specified window length.
  -- The function is designed to be hardware-friendly, meaning it is optimized
  -- for implementation on hardware platforms such as FPGAs or ASICs. It uses
  -- a simple and efficient algorithm to find the peaks, avoiding complex
  -- operations that may not be suitable for hardware implementation.
  -- The function is written in MATLAB and can be used in various applications
  -- such as signal processing, communications, and data analysis.
  -- The function takes the following inputs:
  -- - xcorr: The cross-correlation signal, which is a matrix of size
  --   (num_samples, num_sequences). Each column represents a different
  --   sequence.
  -- - threshold: The threshold value for peak detection, which is a vector
  --   of size (num_samples, 1). The threshold is used to determine if a
  --   sample is considered a peak.
  -- - window_length: The length of the sliding window used for peak
  --   detection. It is a scalar value that specifies the number of samples
  --   to consider in the window.
  -- The function returns the following output:
  -- - locations: A vector containing the indices of the detected peaks in
  --   the cross-correlation signal. The indices are relative to the input
  --   signal and indicate the locations of the detected peaks.
  -- Author: Jie Lei
  -- Date: 03/31/2025
  -- University of Technology Sydney
  -- Copyright 2021-2023 The MathWorks, Inc.
  -- Length of the sliding window
  -- Persistent buffer for current window
  -- Persistent buffer for threshold
  -- Persistent index for the loop
  -- Shift buffer
  p21tmp_output : PROCESS (xcorrBuffer, xcorr_unsigned)
  BEGIN
    tmp_1 <= xcorrBuffer;
    tmp_1(1 TO 10) <= xcorrBuffer(0 TO 9);
    tmp_1(0) <= xcorr_unsigned;
  END PROCESS p21tmp_output;


  MidSample <= tmp_1(5);


  c_gen: FOR t_0 IN 0 TO 10 GENERATE
    p9c_sub_cast(t_0) <= signed(resize(tmp_1(t_0), 17));
    p9c_sub_cast_1(t_0) <= signed(resize(MidSample, 17));
    p9c_sub_temp(t_0) <= p9c_sub_cast(t_0) - p9c_sub_cast_1(t_0);
    p9c_cast(t_0) <= p9c_sub_temp(t_0)(14 DOWNTO 1);
    p9c_cast_1(t_0) <= resize(p9c_cast(t_0), 22);
    
    c(t_0) <= '1' WHEN p9c_cast_1(t_0) <= to_signed(16#000000#, 22) ELSE
        '0';
  END GENERATE c_gen;


  -- Set valid to true if a peak is found
  -- Store the location of the peak
  -- Set valid to false if no peak is found
  -- No peak found
  p8_output : PROCESS (c)
    VARIABLE y : std_logic;
  BEGIN
    y := '1';

    FOR k IN 0 TO 10 LOOP
      y := y AND c(k);
    END LOOP;

    y_1 <= y;
  END PROCESS p8_output;


  threshold_unsigned <= unsigned(threshold);

  thresholdBuffer_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      thresholdBuffer <= (OTHERS => to_unsigned(16#0000#, 14));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        thresholdBuffer <= tmp_2;
      END IF;
    END IF;
  END PROCESS thresholdBuffer_reg_process;


  -- Add new sample to buffer
  -- Shift threshold buffer
  p19tmp_output : PROCESS (thresholdBuffer, threshold_unsigned)
  BEGIN
    tmp_2 <= thresholdBuffer;
    tmp_2(1 TO 10) <= thresholdBuffer(0 TO 9);
    tmp_2(0) <= threshold_unsigned;
  END PROCESS p19tmp_output;


  thresholdBuffer_1 <= tmp_2(5);

  y_2 <= y_1 AND hdlcoder_to_stdlogic(MidSample > thresholdBuffer_1);

  locations_2 <= to_unsigned(16#0000#, 13);

  -- greater than a threshold, it is a local max
  -- if all values in the result are negative and the middle sample is
  -- this is a vector
  -- Hardware friendly implementation of peak finder
  tmp_3 <= index - to_unsigned(16#0005#, 13);

  
  tmp_4 <= locations_2 WHEN y_2 = '0' ELSE
      tmp_3;

  
  tmp_5 <= locations_1 WHEN s_1 = '0' ELSE
      tmp_4;

  locations <= std_logic_vector(tmp_5);

  valid_1 <= '0';

  valid_2 <= '0';

  valid_3 <= '1';

  
  tmp_6 <= valid_2 WHEN y_2 = '0' ELSE
      valid_3;

  
  tmp_7 <= valid_1 WHEN s_1 = '0' ELSE
      tmp_6;

  ce_out <= clk_enable;

  valid <= tmp_7;

END rtl;

