// -------------------------------------------------------------
// 

// File Name: /home/jielei/Projects/UTS/peakPicker/HDLCoder/optim2_HDL/codegen/peakPicker/hdlsrc/peakPicker_fixpt.v
// Created: 2025-03-31 22:19:29
// 
// Generated by MATLAB 24.2, MATLAB Coder 24.2 and HDL Coder 24.2
// 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Design base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// locations                     ce_out        1
// valid                         ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: peakPicker_fixpt
// Source Path: peakPicker_fixpt
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module peakPicker_fixpt
          (clk,
           reset_x,
           clk_enable,
           xcorr,
           threshold,
           ce_out,
           locations,
           valid);


  input   clk;
  input   reset_x;
  input   clk_enable;
  input   [13:0] xcorr;  // ufix14_En21
  input   [13:0] threshold;  // ufix14_En21
  output  ce_out;
  output  [12:0] locations;  // ufix13
  output  valid;


  wire enb;
  wire [13:0] s_s;  // ufix14
  reg [12:0] index;  // ufix13
  wire [13:0] tmp;  // ufix14
  wire [13:0] tmp_1;  // ufix14
  wire [12:0] tmp_2;  // ufix13
  wire s_s_1;
  wire [12:0] locations_1;  // ufix13
  reg [13:0] tmp_3 [0:10];  // ufix14_En21 [11]
  reg [13:0] xcorrBuffer_reg_reg [0:10];  // ufix14 [11]
  wire [13:0] xcorrBuffer_reg_reg_next [0:10];  // ufix14_En21 [11]
  wire [13:0] xcorrBuffer [0:10];  // ufix14_En21 [11]
  wire signed [14:0] tmp_4 [0:10];  // sfix15_En21 [11]
  wire signed [16:0] tmp_5 [0:10];  // sfix17_En21 [11]
  wire [13:0] xcorrBuffer_1;  // ufix14_En21
  wire signed [16:0] tmp_6;  // sfix17_En21
  wire signed [16:0] tmp_7 [0:10];  // sfix17_En21 [11]
  wire signed [13:0] tmp_8 [0:10];  // sfix14_En20 [11]
  wire [10:0] c_c_6;  // boolean [11]
  wire signed [21:0] p28c_cast [0:10];  // sfix22_En20 [11]
  reg  y_y;
  reg [13:0] tmp_9 [0:10];  // ufix14_En21 [11]
  reg [13:0] thresholdBuffer_reg_reg [0:10];  // ufix14 [11]
  wire [13:0] thresholdBuffer_reg_reg_next [0:10];  // ufix14_En21 [11]
  wire [13:0] thresholdBuffer [0:10];  // ufix14_En21 [11]
  wire [13:0] thresholdBuffer_1;  // ufix14_En21
  wire tmp_10;
  wire y_y_1;
  wire [12:0] locations_2;  // ufix13
  wire [13:0] tmp_11;  // ufix14
  wire [13:0] tmp_12;  // ufix14
  wire [12:0] tmp_13;  // ufix13
  wire [12:0] tmp_14;  // ufix13
  wire [12:0] tmp_15;  // ufix13
  reg [12:0] locations_3;  // ufix13
  wire valid_1;
  wire valid_2;
  wire valid_3;
  wire tmp_16;
  wire tmp_17;
  reg  valid_4;
  reg signed [31:0] xcorrBuffer_reg_t_0_0;  // int32
  reg signed [31:0] p42tmp_t_0;  // int32
  reg signed [31:0] p42tmp_t_1;  // int32
  reg signed [31:0] p27_k;  // int32
  reg  p27_y;
  reg signed [31:0] thresholdBuffer_reg_t_0_0;  // int32
  reg signed [31:0] p40tmp_t_0;  // int32
  reg signed [31:0] p40tmp_t_1;  // int32


  assign s_s = 14'b00000000000001;

  assign enb = clk_enable;

  assign tmp = {1'b0, index};

  assign tmp_1 = tmp + s_s;

  assign tmp_2 = tmp_1[12:0];

  // greater than a threshold, it is a local max
  // if all values in the result are negative and the middle sample is
  // this is a vector
  // Hardware friendly implementation of peak finder
  always @(posedge clk or posedge reset_x)
    begin : index_reg_process
      if (reset_x == 1'b1) begin
        index <= 13'b0000000000001;
      end
      else begin
        if (enb) begin
          index <= tmp_2;
        end
      end
    end

  // Add new threshold to buffer
  assign s_s_1 = index >= 13'b0000000001011;

  assign locations_1 = 13'b0000000000000;

  // Increment index for the next iteration
  always @(posedge clk or posedge reset_x)
    begin : xcorrBuffer_reg_process
      if (reset_x == 1'b1) begin
        xcorrBuffer_reg_reg[0] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[1] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[2] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[3] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[4] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[5] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[6] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[7] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[8] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[9] <= 14'b00000000000000;
        xcorrBuffer_reg_reg[10] <= 14'b00000000000000;
      end
      else begin
        if (enb) begin
          for(xcorrBuffer_reg_t_0_0 = 32'sd0; xcorrBuffer_reg_t_0_0 <= 32'sd10; xcorrBuffer_reg_t_0_0 = 
            xcorrBuffer_reg_t_0_0 + 32'sd1) begin
            xcorrBuffer_reg_reg[xcorrBuffer_reg_t_0_0] <= xcorrBuffer_reg_reg_next[xcorrBuffer_reg_t_0_0];
          end
        end
      end
    end

  assign xcorrBuffer[0] = xcorrBuffer_reg_reg[0];
  assign xcorrBuffer_reg_reg_next[0] = tmp_3[0];
  assign xcorrBuffer[1] = xcorrBuffer_reg_reg[1];
  assign xcorrBuffer_reg_reg_next[1] = tmp_3[1];
  assign xcorrBuffer[2] = xcorrBuffer_reg_reg[2];
  assign xcorrBuffer_reg_reg_next[2] = tmp_3[2];
  assign xcorrBuffer[3] = xcorrBuffer_reg_reg[3];
  assign xcorrBuffer_reg_reg_next[3] = tmp_3[3];
  assign xcorrBuffer[4] = xcorrBuffer_reg_reg[4];
  assign xcorrBuffer_reg_reg_next[4] = tmp_3[4];
  assign xcorrBuffer[5] = xcorrBuffer_reg_reg[5];
  assign xcorrBuffer_reg_reg_next[5] = tmp_3[5];
  assign xcorrBuffer[6] = xcorrBuffer_reg_reg[6];
  assign xcorrBuffer_reg_reg_next[6] = tmp_3[6];
  assign xcorrBuffer[7] = xcorrBuffer_reg_reg[7];
  assign xcorrBuffer_reg_reg_next[7] = tmp_3[7];
  assign xcorrBuffer[8] = xcorrBuffer_reg_reg[8];
  assign xcorrBuffer_reg_reg_next[8] = tmp_3[8];
  assign xcorrBuffer[9] = xcorrBuffer_reg_reg[9];
  assign xcorrBuffer_reg_reg_next[9] = tmp_3[9];
  assign xcorrBuffer[10] = xcorrBuffer_reg_reg[10];
  assign xcorrBuffer_reg_reg_next[10] = tmp_3[10];

  // Set valid to false if no peak is found
  // No peak found
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  //                                                                          %
  //          Generated by MATLAB 24.2 and Fixed-Point Designer 24.2          %
  //                                                                          %
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  // Modified from the original peakPicker.m file
  // to use a hardware-friendly implementation of peak finder
  // This function is used to find the locations of peaks in a cross-correlation
  // signal. It takes the cross-correlation signal, a threshold, and a window
  // length as inputs, and returns the locations of the detected peaks.
  // The function uses a sliding window approach to check for local maxima
  // within the specified window length. The middle sample of the window is
  // compared to the other samples in the window, and if it is greater than
  // the threshold, it is considered a peak. The function also ensures that
  // the detected peaks are within the specified window length.
  // The function is designed to be hardware-friendly, meaning it is optimized
  // for implementation on hardware platforms such as FPGAs or ASICs. It uses
  // a simple and efficient algorithm to find the peaks, avoiding complex
  // operations that may not be suitable for hardware implementation.
  // The function is written in MATLAB and can be used in various applications
  // such as signal processing, communications, and data analysis.
  // The function takes the following inputs:
  // - xcorr: The cross-correlation signal, which is a matrix of size
  //   (num_samples, num_sequences). Each column represents a different
  //   sequence.
  // - threshold: The threshold value for peak detection, which is a vector
  //   of size (num_samples, 1). The threshold is used to determine if a
  //   sample is considered a peak.
  // - window_length: The length of the sliding window used for peak
  //   detection. It is a scalar value that specifies the number of samples
  //   to consider in the window.
  // The function returns the following output:
  // - locations: A vector containing the indices of the detected peaks in
  //   the cross-correlation signal. The indices are relative to the input
  //   signal and indicate the locations of the detected peaks.
  // Author: Jie Lei
  // Date: 03/31/2025
  // University of Technology Sydney
  // Copyright 2021-2023 The MathWorks, Inc.
  // Length of the sliding window
  // Persistent buffer for current window
  // Persistent buffer for threshold
  // Persistent index for the loop
  // Shift buffer
  always @* begin

    for(p42tmp_t_0 = 32'sd0; p42tmp_t_0 <= 32'sd10; p42tmp_t_0 = p42tmp_t_0 + 32'sd1) begin
      tmp_3[p42tmp_t_0] = xcorrBuffer[p42tmp_t_0];
    end
    for(p42tmp_t_1 = 32'sd0; p42tmp_t_1 <= 32'sd9; p42tmp_t_1 = p42tmp_t_1 + 32'sd1) begin
      tmp_3[32'sd1 + p42tmp_t_1] = xcorrBuffer[p42tmp_t_1];
    end

    tmp_3[0] = xcorr;
  end

  assign tmp_4[0] = {1'b0, tmp_3[0]};
  assign tmp_4[1] = {1'b0, tmp_3[1]};
  assign tmp_4[2] = {1'b0, tmp_3[2]};
  assign tmp_4[3] = {1'b0, tmp_3[3]};
  assign tmp_4[4] = {1'b0, tmp_3[4]};
  assign tmp_4[5] = {1'b0, tmp_3[5]};
  assign tmp_4[6] = {1'b0, tmp_3[6]};
  assign tmp_4[7] = {1'b0, tmp_3[7]};
  assign tmp_4[8] = {1'b0, tmp_3[8]};
  assign tmp_4[9] = {1'b0, tmp_3[9]};
  assign tmp_4[10] = {1'b0, tmp_3[10]};

  assign tmp_5[0] = {{2{tmp_4[0][14]}}, tmp_4[0]};
  assign tmp_5[1] = {{2{tmp_4[1][14]}}, tmp_4[1]};
  assign tmp_5[2] = {{2{tmp_4[2][14]}}, tmp_4[2]};
  assign tmp_5[3] = {{2{tmp_4[3][14]}}, tmp_4[3]};
  assign tmp_5[4] = {{2{tmp_4[4][14]}}, tmp_4[4]};
  assign tmp_5[5] = {{2{tmp_4[5][14]}}, tmp_4[5]};
  assign tmp_5[6] = {{2{tmp_4[6][14]}}, tmp_4[6]};
  assign tmp_5[7] = {{2{tmp_4[7][14]}}, tmp_4[7]};
  assign tmp_5[8] = {{2{tmp_4[8][14]}}, tmp_4[8]};
  assign tmp_5[9] = {{2{tmp_4[9][14]}}, tmp_4[9]};
  assign tmp_5[10] = {{2{tmp_4[10][14]}}, tmp_4[10]};

  assign xcorrBuffer_1 = tmp_3[5];

  assign tmp_6 = {3'b0, xcorrBuffer_1};

  assign tmp_7[0] = tmp_5[0] - tmp_6;
  assign tmp_7[1] = tmp_5[1] - tmp_6;
  assign tmp_7[2] = tmp_5[2] - tmp_6;
  assign tmp_7[3] = tmp_5[3] - tmp_6;
  assign tmp_7[4] = tmp_5[4] - tmp_6;
  assign tmp_7[5] = tmp_5[5] - tmp_6;
  assign tmp_7[6] = tmp_5[6] - tmp_6;
  assign tmp_7[7] = tmp_5[7] - tmp_6;
  assign tmp_7[8] = tmp_5[8] - tmp_6;
  assign tmp_7[9] = tmp_5[9] - tmp_6;
  assign tmp_7[10] = tmp_5[10] - tmp_6;

  assign tmp_8[0] = tmp_7[0][14:1];
  assign tmp_8[1] = tmp_7[1][14:1];
  assign tmp_8[2] = tmp_7[2][14:1];
  assign tmp_8[3] = tmp_7[3][14:1];
  assign tmp_8[4] = tmp_7[4][14:1];
  assign tmp_8[5] = tmp_7[5][14:1];
  assign tmp_8[6] = tmp_7[6][14:1];
  assign tmp_8[7] = tmp_7[7][14:1];
  assign tmp_8[8] = tmp_7[8][14:1];
  assign tmp_8[9] = tmp_7[9][14:1];
  assign tmp_8[10] = tmp_7[10][14:1];

  assign p28c_cast[0] = {{8{tmp_8[0][13]}}, tmp_8[0]};
  assign c_c_6[0] = p28c_cast[0] <= 22'sb0000000000000000000000;
  assign p28c_cast[1] = {{8{tmp_8[1][13]}}, tmp_8[1]};
  assign c_c_6[1] = p28c_cast[1] <= 22'sb0000000000000000000000;
  assign p28c_cast[2] = {{8{tmp_8[2][13]}}, tmp_8[2]};
  assign c_c_6[2] = p28c_cast[2] <= 22'sb0000000000000000000000;
  assign p28c_cast[3] = {{8{tmp_8[3][13]}}, tmp_8[3]};
  assign c_c_6[3] = p28c_cast[3] <= 22'sb0000000000000000000000;
  assign p28c_cast[4] = {{8{tmp_8[4][13]}}, tmp_8[4]};
  assign c_c_6[4] = p28c_cast[4] <= 22'sb0000000000000000000000;
  assign p28c_cast[5] = {{8{tmp_8[5][13]}}, tmp_8[5]};
  assign c_c_6[5] = p28c_cast[5] <= 22'sb0000000000000000000000;
  assign p28c_cast[6] = {{8{tmp_8[6][13]}}, tmp_8[6]};
  assign c_c_6[6] = p28c_cast[6] <= 22'sb0000000000000000000000;
  assign p28c_cast[7] = {{8{tmp_8[7][13]}}, tmp_8[7]};
  assign c_c_6[7] = p28c_cast[7] <= 22'sb0000000000000000000000;
  assign p28c_cast[8] = {{8{tmp_8[8][13]}}, tmp_8[8]};
  assign c_c_6[8] = p28c_cast[8] <= 22'sb0000000000000000000000;
  assign p28c_cast[9] = {{8{tmp_8[9][13]}}, tmp_8[9]};
  assign c_c_6[9] = p28c_cast[9] <= 22'sb0000000000000000000000;
  assign p28c_cast[10] = {{8{tmp_8[10][13]}}, tmp_8[10]};
  assign c_c_6[10] = p28c_cast[10] <= 22'sb0000000000000000000000;

  // Set valid to true if a peak is found
  // Store the location of the peak
  // Set valid to false if no peak is found
  // No peak found
  always @* begin
    p27_y = 1'b1;

    for(p27_k = 32'sd0; p27_k <= 32'sd10; p27_k = p27_k + 32'sd1) begin
      p27_y = p27_y && c_c_6[p27_k];
    end

    y_y = p27_y;
  end

  always @(posedge clk or posedge reset_x)
    begin : thresholdBuffer_reg_process
      if (reset_x == 1'b1) begin
        thresholdBuffer_reg_reg[0] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[1] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[2] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[3] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[4] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[5] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[6] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[7] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[8] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[9] <= 14'b00000000000000;
        thresholdBuffer_reg_reg[10] <= 14'b00000000000000;
      end
      else begin
        if (enb) begin
          for(thresholdBuffer_reg_t_0_0 = 32'sd0; thresholdBuffer_reg_t_0_0 <= 32'sd10; 
            thresholdBuffer_reg_t_0_0 = thresholdBuffer_reg_t_0_0 + 32'sd1) begin
            thresholdBuffer_reg_reg[thresholdBuffer_reg_t_0_0] <= 
              thresholdBuffer_reg_reg_next[thresholdBuffer_reg_t_0_0];
          end
        end
      end
    end

  assign thresholdBuffer[0] = thresholdBuffer_reg_reg[0];
  assign thresholdBuffer_reg_reg_next[0] = tmp_9[0];
  assign thresholdBuffer[1] = thresholdBuffer_reg_reg[1];
  assign thresholdBuffer_reg_reg_next[1] = tmp_9[1];
  assign thresholdBuffer[2] = thresholdBuffer_reg_reg[2];
  assign thresholdBuffer_reg_reg_next[2] = tmp_9[2];
  assign thresholdBuffer[3] = thresholdBuffer_reg_reg[3];
  assign thresholdBuffer_reg_reg_next[3] = tmp_9[3];
  assign thresholdBuffer[4] = thresholdBuffer_reg_reg[4];
  assign thresholdBuffer_reg_reg_next[4] = tmp_9[4];
  assign thresholdBuffer[5] = thresholdBuffer_reg_reg[5];
  assign thresholdBuffer_reg_reg_next[5] = tmp_9[5];
  assign thresholdBuffer[6] = thresholdBuffer_reg_reg[6];
  assign thresholdBuffer_reg_reg_next[6] = tmp_9[6];
  assign thresholdBuffer[7] = thresholdBuffer_reg_reg[7];
  assign thresholdBuffer_reg_reg_next[7] = tmp_9[7];
  assign thresholdBuffer[8] = thresholdBuffer_reg_reg[8];
  assign thresholdBuffer_reg_reg_next[8] = tmp_9[8];
  assign thresholdBuffer[9] = thresholdBuffer_reg_reg[9];
  assign thresholdBuffer_reg_reg_next[9] = tmp_9[9];
  assign thresholdBuffer[10] = thresholdBuffer_reg_reg[10];
  assign thresholdBuffer_reg_reg_next[10] = tmp_9[10];

  // Add new sample to buffer
  // Shift threshold buffer
  always @* begin

    for(p40tmp_t_0 = 32'sd0; p40tmp_t_0 <= 32'sd10; p40tmp_t_0 = p40tmp_t_0 + 32'sd1) begin
      tmp_9[p40tmp_t_0] = thresholdBuffer[p40tmp_t_0];
    end
    for(p40tmp_t_1 = 32'sd0; p40tmp_t_1 <= 32'sd9; p40tmp_t_1 = p40tmp_t_1 + 32'sd1) begin
      tmp_9[32'sd1 + p40tmp_t_1] = thresholdBuffer[p40tmp_t_1];
    end

    tmp_9[0] = threshold;
  end

  assign thresholdBuffer_1 = tmp_9[5];

  assign tmp_10 = xcorrBuffer_1 > thresholdBuffer_1;

  assign y_y_1 = y_y & tmp_10;

  assign locations_2 = 13'b0000000000000;

  assign tmp_11 = {1'b0, index};

  assign tmp_12 = tmp_11 - 14'b00000000000101;

  assign tmp_13 = tmp_12[12:0];

  assign tmp_14 = (y_y_1 == 1'b0 ? locations_2 :
              tmp_13);

  assign tmp_15 = (s_s_1 == 1'b0 ? locations_1 :
              tmp_14);

  always @(posedge clk or posedge reset_x)
    begin : locations_reg_process
      if (reset_x == 1'b1) begin
        locations_3 <= 13'b0000000000000;
      end
      else begin
        if (enb) begin
          locations_3 <= tmp_15;
        end
      end
    end

  assign valid_1 = 1'b0;

  assign valid_2 = 1'b0;

  assign valid_3 = 1'b1;

  assign tmp_16 = (y_y_1 == 1'b0 ? valid_2 :
              valid_3);

  assign tmp_17 = (s_s_1 == 1'b0 ? valid_1 :
              tmp_16);

  always @(posedge clk or posedge reset_x)
    begin : valid_reg_process
      if (reset_x == 1'b1) begin
        valid_4 <= 1'b0;
      end
      else begin
        if (enb) begin
          valid_4 <= tmp_17;
        end
      end
    end

  assign ce_out = clk_enable;

  assign locations = locations_3;

  assign valid = valid_4;

endmodule  // peakPicker_fixpt

